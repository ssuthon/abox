// this version is include LED 8x8 , RFID , Scale , LCD , sensor , with enc28j60
/*enc28j60 ethernet module
  pin 50 is connected to SO
  pin 51 is connected to SI
  pin 52 is connected to SCK
  pin 53 is connected to CS
  other 4 pin is not necessary
*/
#include <SPI.h>
#include <UIPEthernet.h>
#include <Wire.h>
#include <LCD.h>
#include <LiquidCrystal_I2C.h>
#include "LedControlMS.h"
#include <SHT2x.h>

#define I2C_ADDR 0x27 //i2c scanner address
#define BACKLIGHT_PIN 3 //set up blacklight pin
/*
 pin 12 is connected to the DataIn 
 pin 11 is connected to the CLK 
 pin 10 is connected to LOAD 
 */
LedControl lc=LedControl(12,11,10,1);
// network configuration.  gateway and subnet are optional.

 // the media access control (ethernet hardware) address for the shield:
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };  
//the IP address for the shield:
byte ip[] = { 10, 0, 0, 177 };    
// the router's gateway address:
byte gateway[] = { 10, 0, 0, 1 };
// the subnet:
byte subnet[] = { 255, 255, 0, 0 };
// telnet defaults to port 23
EthernetServer server = EthernetServer(23);
EthernetServer server2 = EthernetServer(24);
LiquidCrystal_I2C lcd(I2C_ADDR,2,1,0,4,5,6,7);
String clearLCD = "                    ";

void setup() {
  Serial.begin(9600); 
  Serial1.begin(9600);
  Serial2.begin(9600);
   // initialize the ethernet device
  Ethernet.begin(mac, ip, gateway, subnet);
  //sensor part
  Wire.begin();
  // start listening for clients
  server.begin();
  server2.begin();
  Serial.println("Server Ready");
  lcd.begin (20,4);
  // Switch on the backlight
  lcd.setBacklightPin(BACKLIGHT_PIN,POSITIVE);
  lcd.setBacklight(HIGH);
  lcd.home ();
  lcd.setCursor(6,1); // ไปทตัวอักษรที่ 3 แถวที่ 2
  lcd.print("PUPASOFT");
  delay(2000);
  lcd.clear();  
  
  //set LED 8x8
  lc.shutdown(0,false);
  lc.setIntensity(0,2);
  lc.clearDisplay(0);
  
}

void loop()
{
  char tmp;
  int i = 0;
  int j = 3;
  int k = 0;
  char rtext[50];
  char text[21];
  byte* ledRow;
  // if an incoming client connects, there will be bytes available to read:
  EthernetClient client = server.available();
  EthernetClient client2 = server2.available();
  while (client) {    
    tmp = client.read();    
    if((tmp >= 'a' && tmp <= 'z')||(tmp >= 'A' && tmp <= 'Z')||(tmp >= '0' && tmp <= '9')||(tmp == '_')){
      rtext[i] = tmp;
      i++;
    }
    else{
      rtext[i] = '\0';
    }
//    Serial.println(tmp);
    client = server.available();
    if(!client){
      //LCD 20x4
      if(rtext[1] >= '1' && rtext[1] <= '4'){
          strcpy(text,DisplayText(rtext));
          Serial.println(text);
          if(rtext[1] == '1'){
            //lcd.clear();
            lcd.setBacklightPin(BACKLIGHT_PIN,POSITIVE);
            lcd.setBacklight(HIGH);
            lcd.setCursor(0,0);
            if(rtext[0] == 'D' && rtext[2] == '_'){
              lcd.print(text);
              server.println("OK D1\r");
            }
            if(rtext[0] == 'E'){
              lcd.print(clearLCD);
              server.println("OK E1\r");
            }
          }
          if(rtext[1] == '2'){
            //lcd.clear();
            lcd.setBacklightPin(BACKLIGHT_PIN,POSITIVE);
            lcd.setBacklight(HIGH);
            lcd.setCursor(0,1);
            if(rtext[0] == 'D' && rtext[2] == '_'){
              lcd.print(text);
              server.println("OK D2\r");
            }
            if(rtext[0] == 'E'){
              lcd.print(clearLCD);
              server.println("OK E2\r");
            }
          }
          if(rtext[1] == '3'){
            //lcd.clear();
            lcd.setBacklightPin(BACKLIGHT_PIN,POSITIVE);
            lcd.setBacklight(HIGH); 
            lcd.setCursor(0,2);
            if(rtext[0] == 'D' && rtext[2] == '_'){
              lcd.print(text);
              server.println("OK D3\r");
            }
            if(rtext[0] == 'E'){
              lcd.print(clearLCD);
              server.println("OK E3\r");
            }
          }
          if(rtext[1] == '4'){
            //lcd.clear();
            lcd.setBacklightPin(BACKLIGHT_PIN,POSITIVE);
            lcd.setBacklight(HIGH); 
            lcd.setCursor(0,3);
            if(rtext[0] == 'D' && rtext[2] == '_'){
              lcd.print(text);
              server.println("OK D4\r");
            }
            if(rtext[0] == 'E'){
              lcd.print(clearLCD);
              server.println("OK E4\r");
            }
          }
      }
      //LED 8x8
      else if((rtext[0] == 'L') && (rtext[1] == 'X') && (rtext[2] == '_') && (strlen(rtext) == 19)){
        lc.clearDisplay(0);
        ledRow = TextToHex(rtext);
//        for(i = 0 ; i < 8 ; i++)
//          Serial.println(ledRow[i]);
        lc.setRow(0,0,ledRow[0]);
        lc.setRow(0,1,ledRow[1]);
        lc.setRow(0,2,ledRow[2]);
        lc.setRow(0,3,ledRow[3]);
        lc.setRow(0,4,ledRow[4]);
        lc.setRow(0,5,ledRow[5]);
        lc.setRow(0,6,ledRow[6]);
        lc.setRow(0,7,ledRow[7]);
        server.println("OK LX\r");
      }
      else if(!strcmp(rtext, "SX")){
        Serial.print("Humidity(%RH): ");
        Serial.print(SHT2x.GetHumidity());
        server.print("Humidity(%RH): ");
        server.print(SHT2x.GetHumidity());
        Serial.print("     Temperature(C): ");
        Serial.println(SHT2x.GetTemperature());
        server.print("     Temperature(C): ");
        server.println(SHT2x.GetTemperature());
        server.println("OK SX\r");
      }
    }  
  }   
}
void serialEvent1()
{
  byte i = 0;
  byte val = 0;
  byte code[6];
  byte checksum = 0;
  byte bytesread = 0;
  byte tempbyte = 0;
  //EthernetClient client = server.available();
  char rf[10] = "RF_";
  if(Serial1.available() > 0) {
    if((val = Serial1.read()) == 2) {                  // check for header 
      bytesread = 0; 
      while (bytesread < 12) {                        // read 10 digit code + 2 digit checksum
        if( Serial1.available() > 0) { 
          val = Serial1.read();
          if((val == 0x0D)||(val == 0x0A)||(val == 0x03)||(val == 0x02)) { // if header or stop bytes before the 10 digit reading 
            break;                                    // stop reading
          }

          // Do Ascii/Hex conversion:
          if ((val >= '0') && (val <= '9')) {
            val = val - '0';
          } else if ((val >= 'A') && (val <= 'F')) {
            val = 10 + val - 'A';
          }

          // Every two hex-digits, add byte to code:
          if (bytesread & 1 == 1) {
            // make some space for this hex-digit by
            // shifting the previous hex-digit with 4 bits to the left:
            code[bytesread >> 1] = (val | (tempbyte << 4));

            if (bytesread >> 1 != 5) {                // If we're at the checksum byte,
              checksum ^= code[bytesread >> 1];       // Calculate the checksum... (XOR)
            };
          } else {
            tempbyte = val;                           // Store the first hex digit first...
          };

          bytesread++;                                // ready to read next digit
        } 
      } 
    
      // Output to Serial:
      if (bytesread == 12) {                          // if 12 digit read is complete
        Serial.print("5-byte code: ");
        server.print(rf);
        for (i=0; i<5; i++) {
          if (code[i] < 16) {
             Serial.print("0");
             server.print("0");
          }
          Serial.print(code[i],HEX);
          server.print(code[i],HEX);
          Serial.print(" ");
        }
        server.println();
        Serial.println();

        Serial.print("Checksum: ");
        Serial.print(code[5], HEX);
        Serial.println(code[5] == checksum ? " -- passed." : " -- error.");
        Serial.println();
      }

      bytesread = 0;
    }
  }
}

void serialEvent2()
{
    byte buf[2048];
    int len;
    //EthernetClient client2;
      if(Serial2.available() > 0){
        len = Serial2.readBytesUntil('\n',buf,2047);
        buf[len++] = '\n';
        server2.write(buf,len);
      }
}

char* DisplayText(char* rtext){
      return (rtext = strcut(rtext,3,20));
}

byte* TextToHex(char* rtext){
  int i=0;
     byte* ledRow = (byte*)malloc(sizeof(byte)*8);
//     Serial.println(rtext);
     strcpy(rtext,strcut(rtext,3,16));
//     Serial.println(rtext);
     ledRow[0] = AddHex(strcut(rtext,0,2));
     ledRow[1] = AddHex(strcut(rtext,2,2));
     ledRow[2] = AddHex(strcut(rtext,4,2));
     ledRow[3] = AddHex(strcut(rtext,6,2));
     ledRow[4] = AddHex(strcut(rtext,8,2));
     ledRow[5] = AddHex(strcut(rtext,10,2));
     ledRow[6] = AddHex(strcut(rtext,12,2));
     ledRow[7] = AddHex(strcut(rtext,14,2));
//     Serial.println("========");
//     for(i = 0 ; i < 8 ; i++)
//          Serial.println(ledRow[i]);
//     Serial.println("========");
    return ledRow;
}
char* strcut(char* str,int init,int len){
    char* newstr = (char*)malloc(sizeof(char)*19);
    int i,j;
    for (i = init ,j = 0 ; i < (init+len) ; i++ , j++) {
      newstr[j] = str[i];
    }
    newstr[j] = '\0';
//    Serial.print("Newstr : ");
//    Serial.println(newstr);
    return newstr;
}

byte AddHex(char* str) {
   byte hex = (byte)((NumHex(str[0])*16) + NumHex(str[1]));
//   Serial.print("HEX:");
//   Serial.println(hex);
   return hex;
}
int NumHex(char hex){
  if(hex >= '0' && hex <= '9')
    return hex -'0';
  if(hex >= 'A' && hex <= 'F'){ 
    Serial.println(10 + (hex - 'A'));
    return 10 + (hex - 'A');  
  }
}
